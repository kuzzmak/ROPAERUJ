package hr.fer.zemris.trisat;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;

public class Algorithm {
	private SATFormula formula;
	private int numberOfTheAlgorithm;
	
	public Algorithm(SATFormula formula, int numberOfTheAlgorithm) {
		this.formula = formula;
		this.numberOfTheAlgorithm = numberOfTheAlgorithm;
	}
	
	public String solve(int numberOfTheAlgorithm) {
		String solution = null;
		switch(numberOfTheAlgorithm) {
			case 1:
				solution = bruteforce();
				break;
			case 2:
				solution = iterativeSearch();
				break;
			case 3:
				solution = alg3();
				break;
			case 4:
				solution = GSAT();
				break;
			case 5:
				solution = RandomWalkSAT();
				break;
			default:
				break;
		}
		if(solution != null) return solution;
		return null;
	}
	
	public BitVector transformStringToBoolean(String vec) {
		
		List<Boolean> bitList= new ArrayList<>();
		int length = vec.length();
		
		for(int index = 0; index < length; index++) {
			char temp = vec.charAt(index);
			switch(temp) {
			case '1':
				bitList.add(true);
				break;
			case '0':
				bitList.add(false);
				break;
			default:
				break;
			}
		}
		return new BitVector(bitList);
	}
	
	public String bruteforce(){
		
		List<String> solutions = new ArrayList<>();
		StringBuilder sb = new StringBuilder("");
		
		int numOfVar = formula.getNumberOfVariables();
		
		for(int i = 0; i < Math.pow(2, numOfVar); i++) {
			sb.append(Integer.toBinaryString(i));
			while(sb.length() < numOfVar) {
				sb.insert(0, '0');
			}
			
			BitVector assignment = transformStringToBoolean(sb.toString());
			
			if(formula.isSatisfied(assignment)) solutions.add(sb.toString());
			
			sb.delete(0, sb.length());
		}
		
		return solutions.get(0);
	}
	
	public String iterativeSearch(){
		
		Random rand = new Random();
		BitVector currentSolution = new BitVector(rand, formula.getNumberOfVariables());
		int currentFitness = fitness(currentSolution, formula);
		
		if(currentFitness == formula.getNumberOfClauses()) return currentSolution.toString(); 
		
		for(int i = 0; i < 100000; i++) {
			
			BitVectorNGenerator ng = new BitVectorNGenerator(new MutableBitVector(currentSolution.bits));
			List<MutableBitVector> neighbours = ng.createNeighborhood();
			
			Map<MutableBitVector, Integer> fit = new HashMap<>();	
			for(MutableBitVector mbv: neighbours) {
				fit.put(mbv, fitness(mbv, formula));
			}
			
			int maxFit = 0;
			for(Map.Entry<MutableBitVector, Integer> m: fit.entrySet()){  			
				if(m.getValue() >= maxFit) {
					maxFit = m.getValue();
				}
			}
		
			List<MutableBitVector> bestNeighbours = new ArrayList<>();
			for(Map.Entry<MutableBitVector, Integer> m: fit.entrySet()){
				if(m.getValue() == maxFit) bestNeighbours.add(m.getKey());
			}
			
//			for(MutableBitVector n: neighbours) {
//				System.out.println(n + " " + fitness(n, formula));
//			}
//			for(MutableBitVector n: bestNeighbours) {
//				System.out.println("\t" + n + " " + fitness(n, formula));
//			}
			
			BitVector bestNeighbour = bestNeighbours.get(rand.nextInt(bestNeighbours.size()));
//			System.out.println("\t\t" + bestNeighbour + " " + fitness(bestNeighbour, formula));
			
			if(maxFit < currentFitness) {
				break;
			}else if(maxFit == formula.getNumberOfClauses()){
				currentSolution = bestNeighbour;
				currentFitness = maxFit;
				break;
			}
			else {
				currentSolution = bestNeighbour;
				currentFitness = maxFit;
			}
		}
		return currentSolution.toString();
	}
	
	public String alg3() {
		
		int percentageUnitAmount = 50;
		int numberOfBest = 2;
		Random rand = new Random();
		// trenutno najbolje rješenje
		BitVector currentSolution = new BitVector(rand, formula.getNumberOfVariables());
		
		SATFormulaStats formulaStats = new SATFormulaStats(formula);
		
		// ažuriranje statistike o klauzulama
		Float[] post = formulaStats.getPost();
		
		while(true) {
			
			BitVectorNGenerator ng = new BitVectorNGenerator(new MutableBitVector(currentSolution.bits));
			List<MutableBitVector> neighbours = ng.createNeighborhood();
			
			formulaStats.setAssignment(currentSolution, true);
			// mapa kojoj je ključ susjed, a vrijednost broj zadovoljenih klauzula
			Map<MutableBitVector, Float> fit = new LinkedHashMap<>();	
			for(MutableBitVector mbv: neighbours) {
				fit.put(mbv, (float)fitness(mbv, formula));
				
				for(int index = 0; index < formula.getNumberOfClauses(); index++) {
					if(formula.getClause(index).isSatisfied(mbv)) {
						fit.put(mbv, fit.get(mbv) + percentageUnitAmount * (1 - post[index]));
					}else {
						fit.put(mbv, fit.get(mbv) - percentageUnitAmount * (1 - post[index]));
					}
				}
			}
			
			fit = sortByValue(fit);
			
			List<MutableBitVector> bestNeighbours = new ArrayList<>();
			
			int count = 0;
			for(Map.Entry<MutableBitVector, Float> entry: fit.entrySet()) {
				bestNeighbours.add(entry.getKey());
				count++;
				if(count == numberOfBest) break;
			}
			
			currentSolution = bestNeighbours.get(rand.nextInt(bestNeighbours.size()));
			//System.out.println(currentSolution);
			//System.out.println(fitness(currentSolution, formula));
			if(fitness(currentSolution, formula) == formula.getNumberOfClauses()) return currentSolution.toString();
		}
	}
	
	
	public String GSAT() {
		
		int maxFlips = 5;
		int maxTries = 1000;
		
		Random rand = new Random();
		
		BitVector solution = null;
		
		for(int i = 0; i < maxTries; i++) {
			//System.out.println(i);
			BitVector currentSolution = new BitVector(rand, formula.getNumberOfVariables());
			
			for(int j = 0; j < maxFlips; j++) {
				
				if(formula.isSatisfied(currentSolution)) return currentSolution.toString();
				
				List<MutableBitVector> sol = new ArrayList<>();
				
				Map<MutableBitVector, Float> fit = new LinkedHashMap<>();
				
				for(int k = 0; k < formula.getNumberOfVariables(); k++) {
					MutableBitVector temp = new MutableBitVector(currentSolution.bits);
					temp.set(k, !temp.get(k));
					fit.put(temp, (float)fitness(temp, formula));
					 
				}
				
				fit = sortByValue(fit);
				
				float best = 0.0f;
				for(Map.Entry<MutableBitVector, Float> entry: fit.entrySet()) {
					if(entry.getValue() < best) break;
					sol.add(entry.getKey());
					best = entry.getValue();
				}
				
				currentSolution = sol.get(rand.nextInt(sol.size()));
				solution = currentSolution;
			}
		}
		return solution.toString();
	}
	
	public String RandomWalkSAT() {
		// broj okreta varijabli u nekom rješenju
		int maxFlips = 5;
		// broj iteracija
		int maxTries = 1000;
		// vjerojatnost da se okrene neka varijabla u klauzuli
		float p = 0.3f;
		
		Random rand = new Random();
		
		BitVector solution = null;
		
		for(int i = 0; i < maxTries; i++) {
			//System.out.println(i);
			BitVector bv = new BitVector(rand, formula.getNumberOfVariables());
			MutableBitVector currentSolution = new MutableBitVector(bv.bits);
			
			for(int j = 0; j < maxFlips; j++) {
				
				if(formula.isSatisfied(currentSolution)) return currentSolution.toString();
	
				Clause unsatisfied = pickUnsatisfiedClause(formula, currentSolution);
				int varNum = 0;
				
				if(rand.nextFloat() <= p) {
					varNum = unsatisfied.getLiteral(rand.nextInt(unsatisfied.getSize()));
					currentSolution.set(varNum, !currentSolution.get(varNum));
				}
				
				if(rand.nextFloat() <= (1 - p)) {
					
					Map<MutableBitVector, Float> fit = new LinkedHashMap<>();
					List<Integer> indexes = unsatisfied.getIndexes();
					for(Integer in: indexes) {
						int tempFit = 0;
						MutableBitVector tempSol= currentSolution.copy();
						tempSol.set(in, !currentSolution.get(in));
						tempFit = fitness(tempSol, formula);
						fit.put(tempSol, (float)tempFit);
					}
					
					fit = sortByValue(fit);
					
					List<MutableBitVector> sol = new ArrayList<>();
					float best = 0.0f;
					for(Map.Entry<MutableBitVector, Float> entry: fit.entrySet()) {
						if(entry.getValue() < best) break;
						sol.add(entry.getKey());
						best = entry.getValue();
					}
					
					currentSolution = sol.get(rand.nextInt(sol.size()));
					solution = currentSolution;
				}
			}
		}
		return solution.toString();
	}
	
	/**
	 * Funkcija služi za izračun dobrote određenog rješenja tipa BitVector.
	 * Dobrota je izračunata kao broj zadovoljenih klauzula neke formule.
	 * 
	 * @param assignment BitVector kojeg se izračunava fitness
	 * @param formula SATFormula koju treba zadovoljiti
	 * @return int vrijednost broja zadovoljenih klauzula
	 */
	public int fitness(BitVector assignment, SATFormula formula) {
		int satisfiedClauses = 0;
		
		for(int i = 0; i < formula.getNumberOfClauses(); i++) {
			if(formula.getClause(i).isSatisfied(assignment)) satisfiedClauses++;
		}
		return satisfiedClauses;
	}
	
	/**
	 * Funkcija služi za sortiranje mape silaznim redoslijedom, a moguće
	 * je da postoji više istih vrijednosti
	 * 
	 * @param wordCounts mapa koju je potrebno sortirati
	 * @return sortirana mapa tipa LinkedHashMap
	 */
	public static Map<MutableBitVector, Float> sortByValue(final Map<MutableBitVector, Float> map) {
        return map.entrySet()
                .stream()
                .sorted((Map.Entry.<MutableBitVector, Float>comparingByValue().reversed()))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));
    }
	
	/**
	 * Funkcija služi za dohvat jedne random odabrane nezadovoljene klauzule
	 * tipa Clause, ako ne postoji vraća se null
	 * 
	 * @param formula zadana formula 
	 * @param assignment BitVector potencijalnog rješenja
	 * @return nezadovoljena Clause ako postoji
	 */
	public Clause pickUnsatisfiedClause(SATFormula formula, BitVector assignment) {
		
		List<Clause> unsatisfiedClauses = new ArrayList<>();
		Random rand = new Random();
		
		for(int index = 0; index < formula.getNumberOfClauses(); index++) {
			// ako klauzula ne zadovoljava, stavimo ju u listu 
			if(!formula.getClause(index).isSatisfied(assignment)) { 
				unsatisfiedClauses.add(formula.getClause(index));
			}
		}
		
		// ako postoji neka klauzula u listi
		if(unsatisfiedClauses.size() != 0) {
			return unsatisfiedClauses.get(rand.nextInt(unsatisfiedClauses.size()));
		}else {
			return null;
		}
	}

	
}
